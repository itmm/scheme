(define nil ())
(define (cadr l)
  (car (cdr l)))
(define (cddr l)
  (cdr (cdr l)))
(define (caddr l)
  (car (cddr l)))
(define (cdddr l)
  (cdr (cddr l)))
(define (list . l) l)
(define true #t)
(define false #f)
(define (null? a) (eq? a '()))
(define (> a b)
  (< b a))
(define (not a) (if a #f #t))
(define (abs x) (if (< x 0) (- x) x))
(define (even? x) (= (remainder x 2) 0))
(define (odd? x) (not (even? x)))

(define + (lambda-case
	   (() 0)
	   ((a) a)
	   ((a b) (@binary+ a b))
	   (x (apply + (@binary+ (car x) (cadr x)) (cddr x)))))
(define - (lambda-case
	   (() 0)
	   ((a) (@binary- 0 a))
	   ((a b) (@binary- a b))
	   (x (apply - (@binary- (car x) (cadr x)) (cddr x)))))
(define * (lambda-case
	   (() 1)
	   ((a) a)
	   ((a b) (@binary* a b))
	   (x (apply * (@binary* (car x) (cadr x)) (cddr x)))))
(define / (lambda-case
	   (() 1)
	   ((a) (@binary/ 1 a))
	   ((a b) (@binary/ a b))
	   (x (apply / (@binary/ (car x) (cadr x)) (cddr x)))))

(define (map f ls . more)
  (if (null? more)
      (let map1 ([ls ls])
        (if (null? ls)
            '()
            (cons (f (car ls))
	          (map1 (cdr ls)))))
      (let map-more ([ls ls] [more more])
        (if (null? ls)
	    '()
	    (cons
	      (apply f (car ls) (map car more))
	      (map-more (cdr ls) (map cdr more)))))))

(define (exists f ls . more)
  (and (not (null? ls))
       (let exists_ ([x (car ls)] [ls (cdr ls)] [more more])
	 (if (null? ls)
	     (apply f x (map car more))
	     (or (apply f x (map car more))
	         (exists_ (car ls) (cdr ls) (map cdr more)))))))
